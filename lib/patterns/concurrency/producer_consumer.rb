# Шаблон Producer/Consumer (Производитель/Потребитель) относится к категории конкурентных (concurrent) шаблонов проектирования, которые используются для решения задач взаимодействия между потоками или процессами в многозадачной среде. Он также относится к более широкому классу поведенческих паттернов, поскольку описывает, как объекты или компоненты взаимодействуют друг с другом.

# Основные особенности шаблона Producer/Consumer:
# Разделение обязанностей:

# Producer (Производитель): Создает данные или задачи.
# Consumer (Потребитель): Обрабатывает эти данные или задачи.
# Очередь или буфер: Между производителем и потребителем часто используется очередь или буфер для синхронизации. Производитель помещает данные в очередь, а потребитель их извлекает.

# Параллелизм: Этот шаблон часто применяется в параллельных или многопоточных системах, где производитель и потребитель работают одновременно, но их скорости могут различаться.

# Синхронизация: Важная часть шаблона — правильная синхронизация доступа к общему ресурсу (например, к очереди), чтобы избежать гонок и блокировок.

# Пример:
# У нас есть несколько котиков, которые производят (просят еду).
# И есть один хозяин, который получает запросы котиков и обрабатывает их (кормит котиков).

require 'thread'

# Очередь для синхронизации между котиками (producers) и хозяином (consumer)
queue = Queue.new

# Массив котиков
cats = ['Мурзик', 'Барсик', 'Василий', 'Снежок']

# Producer: котики просят еду
producers = cats.map do |cat|
  Thread.new do
    3.times do
      puts "#{cat}: хочу кушать!"
      # Котик кладет в очередь запрос на еду
      queue << "#{cat} просит еды"
      sleep(rand(1..3)) # Ждут некоторое время перед следующим запросом
    end
  end
end

# Consumer: хозяин кормит котиков
consumer = Thread.new do
  12.times do
    request = queue.pop # Получает запрос из очереди
    puts "Хозяин: обрабатываю запрос - #{request}"
    sleep(2) # Обработка запроса (кормим котика)
    puts "Хозяин: покормил котика!"
  end
end

# Ждем завершения всех потоков
producers.each(&:join)
consumer.join


