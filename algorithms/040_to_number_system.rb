def to_decimal_system(num, sys)
  num.to_s.chars.reverse.map.with_index do |n,i|
    (n.to_i)*(sys**i)
  end.sum
end
puts "binary number:"
p num = 11101011
puts "decimal number:"
p res = to_decimal_system(11101011, 2)
puts "test string:"
p res.to_s(2)

# Побитовые операторы в Ruby

# Предположим, что a = 60; и b = 13; теперь в двоичном формате они будут выглядеть следующим образом:
# a    =  0011 1100
# b    =  0000 1101
# ------------------
# a&b  =  0000 1100
# a|b  =  0011 1101
# a^b  =  0011 0001
# ~a   =  1100 0011

# Язык Ruby поддерживает следующими побитовые операторы:

# & - копирует бит в результат, если он существует в обоих операндах.	(a & b) даст 12, что составляет 0000 1100
# |	- копирует бит, если он существует в любом из операндов.	(a | b) даст 61, что составляет 0011 1101
# ^	- копирует бит, если он установлен в один операнд, но не тот и другой.	(a ^ b) даст 49, то есть 0011 0001
# ~	- имеет эффект «flipping» бит.	(~ a) даст -61, что составляет 1100 0011 в форме дополнения 2 из-за подписанного двоичного числа.
# << - значение левых операндов перемещается влево на количество бит, заданных правым операндом.	a << 2 даст 240, что составляет 1111 0000
# >> - значение левых операндов перемещается вправо на количество бит, заданных правым операндом.	a >> 2 даст 15, то есть 0000 1111

p hex = "%x" % 1234 # "4d2"
p oct = "%о" % 1234 # "2322"
p bin = "%b" % 1234 # "10011010010"

puts 2.to_s(2) #=> 10
puts 11.to_s(2) #=> 1011
puts 'aa'.to_i(16) #=> 170
puts 'fe'.to_i(16) #=> 254
a = 0xff+0xee #=> 493
b= a.to_s(16) #=> 1ed
puts b
puts b.to_i(16) #=> 493

class Fixnum
  def to_hex
    "0x" << self.to_s(16)
  end
  def to_binary
    "0b" << self.to_s(2)
  end
end

puts 16.to_hex #=> 0x10
puts (16+16).to_hex #=> 0x20
puts 3.to_binary #=> 0b11
